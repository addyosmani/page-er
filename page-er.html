<link rel="import" href="../polymer/polymer.html">

<!--
A Polymer element for paginating data, rendering a set of pagination controls for navigating through that data.

<a href="demo/basic.html"><img src="http://i.imgur.com/4m71sz1.png" width="90%"/></a>

<a href="demo/custom.html"><img src="http://i.imgur.com/Xb8ypzV.png" width="90%"/></a>

### Examples

    <page-er perpage="5"></page-er>

    <page-er perpage="10" currentpage="3"></page-er>

    <page-er next="Next >" previous="< Previous "></page-er>

### Installation

To install the element with Bower, run:

    $ bower install page-er --save

Alternatively, you can [download](https://github.com/addyosmani/page-er/releases) a release from the releases page.

### Usage

__Assume we have a list of items we want to paginate__

    var items = []; // Assume this is populated

__Define a page-er in your page. Specify the items per page.__

    <page-er perpage="5"></page-er>

__When ready, set the <code>data</code> for the page-er__

    var pager = document.querySelector('page-er');

    document.addEventListener('WebComponentsReady', function() {
      pager.data = items;
    });

__When page-er has paginated your data, set it as the items property for your results template__

    var results = document.querySelector("template");

    document.addEventListener('pager-data', function(e) {
      results.items = e.detail.data;
    });

__When your selected page changes, also update the results template__

    document.addEventListener('pager-change', function(e) {
      results.items = e.detail.data;
    });

## Styling

Style the page-er with CSS as you would a normal DOM element.

    page-er .pagination li.active button {
      background: #E91E63;
    }

    page-er .pagination li.disabled button {
      background: #B1B9E1;
    }

A [live demo](demo/basic.html) using custom styling is available.

## Custom Pagination Templates

Custom templates for the pagination controls may be specified using the `custom-template`
attribute, passing in your template to the Light DOM of your `page-er` element.

For example, if we wanted to use Polymer `<paper-button>`s instead of the default `<button>`
we could define a custom template as follows:

    <page-er perpage="5" currentpage="0" custom-template>

      <template>

        <div class="pagination" id="pagination">
          <ul>
            <li><paper-button on-click="firstPage">First</paper-button></li>

            <li class$="[[computeTernary(currentpage, 0, 'disabled')]]">
              <paper-button on-click="prevPage">Previous</paper-button>
            </li>

            <template is="dom-repeat" items="[[currentRange]]" as="n">
              <li class$="[[computeTernary(currentpage, n, 'active')]]" on-click="setPage">
                <paper-button data-item$="[[n]]" class="colored" label="[[computePageNum(n)]]" raised>[[computePageNum(n)]]</button>
              </li>
            </template>

            <li class$="[[computeTernary(currentpage, pageCount, 'disabled')]]">
              <paper-button on-click="nextPage">Next</paper-button>
            </li>

            <li><paper-button on-click="lastPage">Last</paper-button></li>
          </ul>
        </div>

      </template>

    </page-er>

which would produce something like this:

<img src="http://i.imgur.com/23TpUFy.png" width="80%"/>

A [live demo](demo/paper.html) of the above is also available. The [dark themed](demo/custom.html) version you see earlier on also uses a custom template.

## Routing

`page-er` doesn't include built in support for routing, but you are free to use a routing
library or element of choice with it. In our [routing demo](demo/routing.html) we use the [flatiron-director](https://github.com/PolymerLabs/flatiron-director)
element, updating the current paginated page based on the returned route:

    document.addEventListener('WebComponentsReady', function() {
      pager.data = items;
      pager.changePage(router.route);
    });

<img src="http://i.imgur.com/eAHVwnc.png" width="60%"/>

Whenever the paginator triggers a change in the paged set of data, we can similarly update the
route:

    document.addEventListener('pager-change', function(e) {
      results.items = e.detail.data;
      router.route = e.detail.page;
    });

How you choose to approach routing (e.g URLs/routes first) is ultimately up to you and `page-er`
is there to support you with model pagination foremost.

@demo
-->
<dom-module id="page-er">
  <template>
    <link rel="stylesheet" href="page-er.css">

    <content></content>

    <div class="pagination">
      <!-- By default, if no customTemplate is supplied use our own -->
      <template is="dom-if" if="[[!customTemplate]]">
        <ul>
          <li><button on-click="firstPage">First</button></li>
          <li class$="[[computeTernary(currentpage, 0, 'disabled')]]">
            <button on-click="prevPage">[[previous]]</button>
          </li>
          <template is="dom-repeat" items="[[currentRange]]" as="n">
            <li class$="[[computeTernary(currentpage, n, 'active')]]">
              <button data-item$="[[n]]" on-click="setPage">[[computePageNum(n)]]</button>
            </li>
          </template>
          <li class$="[[computeTernary(currentpage, pageCount, 'disabled')]]">
            <button on-click="nextPage">[[next]]</button>
          </li>
          <li><button on-click="lastPage">Last</button></li>
        </ul>
      </template>
    </div>
  </template>
  <script>
  Polymer({
    is: 'page-er',

    behaviors: [Polymer.Templatizer],

    properties: {
      /**
       * The `perpage` property defines the number
       * of items to show per page
       */
      perpage: {
        type: Number,
        value: 10,
        observer: '_currentpageChanged'
      },
      /**
       * The `currentpage` property specifies the
       * current active page in view
       */
      currentpage: {
        type: Number,
        value: 0,
        observer: '_currentpageChanged'
      },
      /**
       * The `currentRange` property specifies the
       * range of pages (e.g 1, 2, 3, 4, 5) to display
       */
      currentRange: {
        type: Array,
        computed: '_computeRange(currentpage, pageCount, rangeSize)'
      },
      /**
       * If true, the default pagination template won't be rendered
       */
      customTemplate: {
        type: Boolean,
        value: false
      },
      /**
       * The `pageCount` specifies the number of paginated pages
       */
      pageCount: {
        type: Number,
        computed: '_computePageCount(data, perpage)'
      },
      /**
       * The `rangeSize` attribute specifies the total size
       * of the paginated range of items
       */
      rangeSize: {
        type: Number,
        value: 10
      },
      /**
       * The `items` property is a list of paginated items to be displayed on a page.
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true,
        computed: '_computeItems(data, currentpage, perpage)'
      },
      /**
       * The `data` property is the complete set of data we
       * wish to be paginated
       */
      data: {
        type: Array,
        value: function() { return []; },
        observer: '_dataChanged'
      },
      /**
       * The `previous` property specifies the label
       * for the Previous button
       */
      previous: {
        type: String,
        value: "<< Prev"
      },
      /**
       * The `next` property specifies the label
       * for the Next button
       */
      next: {
        type: String,
        value: "Next >>"
      }
    },

    observers: [
      '_propsChanged(currentRange, currentpage, pageCount, perpage)'
    ],

    /**
     * Navigate to the first page
     */
    firstPage: function () {
      this.currentpage = 0;
    },

    /**
     * Navigate to the last page
     */
    lastPage: function () {
      this.currentpage = this.pageCount;
    },

    /**
     * Called when navigating to the previous page
     *
     * @event pager-previous
     * @param {number} page Current page
     */

    /**
     * Navigate to the previous page
     */
    prevPage: function () {
      if ( this.currentpage > 0 ) {
        this.currentpage--;
        this.fire('pager-previous', { page: this.currentpage });
      }
    },

    /**
     * Called when navigating to the next page
     *
     * @event pager-next
     * @param {number} page Current page
     */

    /**
     * Navigate to the next page
     */
    nextPage: function () {
      if ( this.currentpage < this.pageCount ) {
        this.currentpage++;
        this.fire('pager-next', { page: this.currentpage });
      }
    },

    /**
     * Updates the current page if the page is in bound
     *
     * @param {string} page
     */
    changePage: function (page) {
      var desiredPage = parseInt(page, 10);
      if (desiredPage <= this.pageCount) {
        this.currentpage = desiredPage;
      }
    },

    setPage: function (event) {
      this.currentpage = parseInt( event.target.dataset.item, 10 );
    },

    computePageNum: function(n) {
      return n + 1;
    },

    /**
     * It is kind of a helper method which can be used in templates in place of
     * the ternary operator which doesn't work there.
     */
    computeTernary: function(givenVal, expectedVal, trueVal, falseVal) {
      return givenVal === expectedVal ? trueVal : falseVal;
    },

    _computePageCount: function (perpage) {
      return Math.ceil( this.data.length / this.perpage ) - 1;
    },

    _computeRange: function (currentpage, pageCount, rangeSize) {
      var paginations = [];
      var start = currentpage;

      if ( start > pageCount - rangeSize ) {
        start = pageCount - rangeSize + 1;
      }

      for ( var i = 0; i < start + rangeSize; i++ ) {
        paginations.push(i);
      }

      return paginations;
    },

    _computeItems: function (data, currentpage, perpage) {
      return data.slice(currentpage * perpage, (currentpage * perpage) + perpage);
    },

    /**
     * Called when the data property is set
     *
     * @event pager-data
     * @param {array} data The list of paginated items to be displayed on a page
     */

    _dataChanged: function() {
      this.fire('pager-data', { data: this.items });
    },

    /**
     * Called when the current page changes
     *
     * @event pager-change
     * @param {number} page Current page
     * @param {array} data The list of paginated items to be displayed on a page
     */
    _currentpageChanged: function (page) {
      this.fire('pager-change', { page: page, data: this.items });
    },

    _perpageChanged: function () {
      this._currentpageChanged();
    },

    /**
     * Forwards properties to a custom template with pagination controls.
     */
    _propsChanged: function(currentRange, currentpage, pageCount) {
      this._forwardParentProp('currentRange', currentRange);
      this._forwardParentProp('currentpage', currentpage);
      this._forwardParentProp('pageCount', pageCount);
    },

    _forwardParentProp: function(prop, value) {
      if (this.instance) {
        this.instance.__setProperty(prop, value, true);
      }
    },

    ready: function () {
      if (this.customTemplate) {
        var template = this.queryEffectiveChildren('template');

        /**
         * this hack most likely will stop working with some new version of Polymer,
         * but currently it provides a nice way to share event listeners and helper methods
         * with a custom template providing the pagination controls. Embedding of custom pagination
         * controls is reached by using the Polymer.Templatizer (https://www.polymer-project.org/1.0/docs/api/Polymer.Templatizer).
         */
        this.dataHost = this;

        this.templatize(template);

        this.instance = this.stamp({
          previous: this.previous,
          next: this.next
        });

        Polymer.dom(this).appendChild(this.instance.root);
      }
    }
  });
  </script>
</dom-module>
